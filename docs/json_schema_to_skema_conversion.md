# JSON Schema to Skema Conversion

This document describes how to convert JSON Schema documents to Skema schema maps.

## Overview

The JSON Schema to Skema converter transforms standard JSON Schema documents into Skema schema definitions. This enables:

- Importing existing API schemas into Skema projects
- Converting OpenAPI specifications to Skema validation
- Migrating from JSON Schema-based validation systems
- Standardizing validation across different platforms

**Note**: Only generates schema maps. Schema modules (using `defschema`) are not generated by this converter.

## Type Mappings

### Basic Types

| JSON Schema Type | Skema Type | Notes |
|------------------|------------|-------|
| `"type": "string"` | `:string` | Direct mapping |
| `"type": "integer"` | `:integer` | Direct mapping |
| `"type": "number"` | `:float` | Mapped to float by default |
| `"type": "boolean"` | `:boolean` | Direct mapping |
| `"type": "object"` | `:map` | Generic object mapping |
| `"type": "array"` | `:array` | Generic array mapping |
| `"type": "null"` | `:any` | Mapped to any type |
| No type specified | `:any` | Default when type is omitted |

### String Format Types

| JSON Schema Format | Skema Type |
|-------------------|------------|
| `"format": "date"` | `:date` |
| `"format": "time"` | `:time` |
| `"format": "date-time"` | `:datetime` |
| `"format": "email"` | `:string` with `format: ~r/.+@.+\..+/` |
| `"format": "uri"` | `:string` with appropriate pattern |
| `"format": "uuid"` | `:string` with UUID pattern |

### Complex Types

| JSON Schema | Skema Type |
|-------------|------------|
| `"type": "array", "items": {...}` | `{:array, type}` |
| `"type": "object", "properties": {...}` | `%{...}` (nested schema) |
| `"const": value` | `in: [value]` constraint |

## Validation Mappings

### Required Fields

```json
// JSON Schema
{
  "type": "object",
  "properties": {
    "name": {"type": "string"},
    "email": {"type": "string"}
  },
  "required": ["name", "email"]
}
```

```elixir
# Skema
%{
  name: [type: :string, required: true],
  email: [type: :string, required: true]
}
```

### String Constraints

```json
// Length constraints
{
  "properties": {
    "username": {
      "type": "string",
      "minLength": 3,
      "maxLength": 20
    },
    "code": {
      "type": "string",
      "minLength": 6,
      "maxLength": 6
    }
  }
}
```

```elixir
# Skema
%{
  username: [type: :string, length: [min: 3, max: 20]],
  code: [type: :string, length: [equal_to: 6]]
}
```

### Pattern Matching

```json
// Regex patterns
{
  "properties": {
    "email": {
      "type": "string",
      "pattern": ".+@.+\\..+"
    },
    "phone": {
      "type": "string",
      "pattern": "^\\d{10}$"
    }
  }
}
```

```elixir
# Skema
%{
  email: [type: :string, format: ~r/.+@.+\..+/],
  phone: [type: :string, format: ~r/^\d{10}$/]
}
```

### Numeric Constraints

```json
// Number constraints
{
  "properties": {
    "age": {
      "type": "integer",
      "minimum": 0,
      "maximum": 150
    },
    "score": {
      "type": "number",
      "minimum": 0,
      "maximum": 100,
      "exclusiveMinimum": true,
      "exclusiveMaximum": true
    },
    "count": {
      "type": "integer",
      "const": 42
    }
  }
}
```

```elixir
# Skema
%{
  age: [type: :integer, number: [min: 0, max: 150]],
  score: [type: :float, number: [greater_than: 0, less_than: 100]],
  count: [type: :integer, in: [42]]
}
```

### Enumeration

```json
// Enum and exclusion
{
  "properties": {
    "status": {
      "type": "string",
      "enum": ["active", "inactive", "pending"]
    },
    "role": {
      "type": "string",
      "not": {
        "enum": ["admin", "super_admin"]
      }
    }
  }
}
```

```elixir
# Skema
%{
  status: [type: :string, in: ["active", "inactive", "pending"]],
  role: [type: :string, not_in: ["admin", "super_admin"]]
}
```

### Array Constraints

```json
// Array with constraints
{
  "properties": {
    "tags": {
      "type": "array",
      "items": {"type": "string"},
      "minItems": 1,
      "maxItems": 5
    },
    "coordinates": {
      "type": "array",
      "items": {"type": "number"},
      "minItems": 2,
      "maxItems": 2
    }
  }
}
```

```elixir
# Skema
%{
  tags: [type: {:array, :string}, length: [min: 1, max: 5]],
  coordinates: [type: {:array, :float}, length: [equal_to: 2]]
}
```

### Default Values

```json
// Default values
{
  "properties": {
    "active": {
      "type": "boolean",
      "default": true
    },
    "count": {
      "type": "integer",
      "default": 0
    },
    "tags": {
      "type": "array",
      "items": {"type": "string"},
      "default": []
    }
  }
}
```

```elixir
# Skema
%{
  active: [type: :boolean, default: true],
  count: [type: :integer, default: 0],
  tags: [type: {:array, :string}, default: []]
}
```

## Complex Example

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "properties": {
    "name": {
      "type": "string",
      "minLength": 2,
      "maxLength": 50
    },
    "age": {
      "type": "integer",
      "minimum": 0,
      "maximum": 150
    },
    "email": {
      "type": "string",
      "pattern": ".+@.+\\..+"
    },
    "status": {
      "type": "string",
      "enum": ["active", "inactive"],
      "default": "active"
    },
    "tags": {
      "type": "array",
      "items": {"type": "string"},
      "maxItems": 10,
      "default": []
    },
    "profile": {
      "type": "object",
      "properties": {
        "bio": {
          "type": "string",
          "maxLength": 500
        },
        "website": {
          "type": "string",
          "pattern": "^https?:\\/\\/.+"
        },
        "social_links": {
          "type": "array",
          "items": {"type": "string"},
          "maxItems": 5
        }
      }
    },
    "scores": {
      "type": "array",
      "items": {"type": "integer"}
    },
    "metadata": {
      "type": "object",
      "default": {}
    }
  },
  "required": ["name"]
}
```

```elixir
# Converted Skema schema
%{
  name: [type: :string, required: true, length: [min: 2, max: 50]],
  age: [type: :integer, number: [min: 0, max: 150]],
  email: [type: :string, format: ~r/.+@.+\..+/],
  status: [type: :string, in: ["active", "inactive"], default: "active"],
  tags: [type: {:array, :string}, length: [max: 10], default: []],
  profile: %{
    bio: [type: :string, length: [max: 500]],
    website: [type: :string, format: ~r/^https?:\/\/.+/],
    social_links: [type: {:array, :string}, length: [max: 5]]
  },
  scores: [type: {:array, :integer}],
  metadata: [type: :map, default: %{}]
}
```

## Unsupported JSON Schema Features

The following JSON Schema features cannot be converted to Skema:

### Schema Composition
- **`allOf`** - No direct equivalent in Skema
- **`oneOf`** - No direct equivalent in Skema
- **`anyOf`** - No direct equivalent in Skema
- **`$ref`** - Schema references not supported

### Advanced Constraints
- **`multipleOf`** - No numeric multiple validation in Valdi
- **`uniqueItems`** - No array uniqueness validation
- **`contains`** - No array contains validation
- **`propertyNames`** - No property name pattern validation
- **`additionalProperties`** - No control over extra properties
- **`patternProperties`** - No pattern-based property validation

### Conditional Logic
- **`if/then/else`** - No conditional validation
- **`dependencies`** - No field dependencies
- **`dependentRequired`** - No conditional required fields

### Meta-Schema Features
- **`$schema`** - Meta information, not validation logic
- **`$id`** - Schema identification
- **`title`** - Schema title
- **`description`** - Schema description
- **`examples`** - Usage examples

## Conversion Strategies

### Handling Unsupported Features

1. **Skip unsupported constraints** - Log warnings for ignored features
2. **Approximate when possible** - Convert `multipleOf` to range validation
3. **Use fallback types** - Default to `:any` for complex compositions
4. **Preserve in metadata** - Store unsupported features as comments

### Missing Type Handling

When JSON Schema doesn't specify a type:
- Use explicit `"type"` property when present
- Map `"format"` to appropriate Skema type (`"format": "date"` â†’ `:date`)
- Default to `:any` type for unspecified types

### Pattern Conversion

JSON Schema regex patterns may need adjustment:
- Escape sequences differ between JSON and Elixir
- Some regex features may not be supported
- Test converted patterns thoroughly

## Conversion API

```elixir
# Convert JSON Schema to Skema schema map
schema = Skema.JsonSchema.to_schema(json_schema)

# Convert with options
schema = Skema.JsonSchema.to_schema(json_schema,
  strict: false,           # Skip unsupported features vs error
  default_type: :any       # Default type when type is missing
)
```

## Best Practices

1. **Validate converted schemas** - Test with sample data
2. **Handle unsupported features** - Document what was skipped
3. **Review type mappings** - Ensure appropriate Skema types
4. **Test regex patterns** - Verify pattern compatibility
5. **Use explicit types** - Prefer JSON Schemas with explicit `"type"` properties
6. **Document conversions** - Track schema evolution

## Limitations

- Only basic JSON Schema features are supported
- Schema composition (`allOf`, `oneOf`, etc.) is not supported
- Advanced constraints may be lost in conversion
- Regex patterns may need manual adjustment
- Meta-schema information is not preserved
- Some numeric constraints (`multipleOf`) have no equivalent